This project explores different methods for memory paging. Using a CPU simulator and prebuilt functions for paging in and paging out pages from memory, this project explored different mechanisms for predictively paging in pages needed in the future and paging out pages that will not be needed in the near future. Information about the environment is contained in simulator.h

pager-lru.c explores an extremely basic paging mechanism. It uses a local page replacement strategy using the Least Recently Used algorithm. In this piece of code, a static variable called tick is used to represent time. After every call to the simulated MMU, this tick variable is increased, and any pages being referenced at the MMU call have their reference time updated. If there are no free frames, the in-memory page accessed furthest in the past is evicted.

pager-predict.c explores a more complex paging mechanism. With each invocation to the simulated MMU, a static data structure is used to store which page has been accessed, and which page was accessed at the last call to the MMU. If the last accessed page differs from the current page, both the last page and the current page is stored. In this way, as pages are re-accessed, it can be determined what the most likely next page access will be. We then page in these pages so that they will be already loaded into memory, thus reducing any latency waiting for a page in operation when the next page is needed. Any pages not currently in use that will not be needed in the near future are evicted to keep a pool of free frames. This method resulted in the best ratio of active CPU cycles to blocked CPU cycles, averaging around 0.03 blocked cycles for every active cycle.

pager-predict-not-basic-attempt-1.c attempted to use state-space analysis to get even better results. A matrix was used for each process to store the pattern of page calls. Entry [i,j] in the matrix corresponds to the number of times we jump from page i to page j in the control flow of the process. Using this matrix and the pseudo-code given by pgm1.pseudo, pgm2.pseudo, â€¦, pgm5.pseudo, we can effectively determine what type of process is running for each process in the simulated environment. Again consulting the pseudo-code given, any pages that will be needed in the near future are paged in, and any pages not needed in the near future are evicted. However, due to the small number of frames in the environment and the branching behavior of many of the processes, thrashing became an issue, whereby too many pages could be needed in the near future without enough frames to hold all of them, resulting in unexpected behavior. This resulted in poorer performance than the mechanism used in pager-predict.c
